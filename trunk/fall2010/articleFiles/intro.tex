\section{Introduction} \label{sec:intro}

\subsection{idea for running example}
A user issues two queries as seen in fig. \ref{fig:advancedroutequery}. We can then argue, using this figures and the map in fig. \ref{fig:map10} about all the optimizations we plan to use. (same queries in all figures, and they correspond to map)




\section{Motivation}
Previous work on caching focus on domains which usually has two key characteristics: data locality and limited set of possible items which can be cached (\cite{ref.}). 
There has not been any previous work done developing a caching scheme usable in domains with large set of possible cacheable items and little or no locality in new items added to system, or suggested added to cache. \spath caching is one such domain. 

\spath calculation is much slower than retrieval from cache, as a cache can supply a \spath directly. 
%where a \spath algorithm will on at most have to visit $AF^{AVN}$ nodes (see table of notation). 
\spath service providers want to spend less money on hardware (\cite{ref.}) and users want fast response time which (\cite{ref.}), when compared to investing in more hardware and bandwith, can be archived in a much cheaper and scalable way by implementing a \spath cache.

Returning a precomputed \spath result is faster, however, it is not feasible to store all possible \spaths. The cache replacement policy of a \spath cache ensures that most queries can be answered by the cache, ensuring as many queries as possible is answered with the space available to the \spath cache.



No previous work has been done on caching \spath query results. interesting problem

More users now have a GPS and Web enabled mobile devices which makes \spath services more popular, but also require them to serve much larger set of users.








% 
% \subsubsection{OSC - Optimal Substructure Cache}
% OSC is more advanced than the two previous proposed solutions and therefor the scenario has been updated in figure . 
% To further improve upon Improved Baseline we will again utilize the optimal substructure, making it possible to have much fewer items in cache and still retain a high cache hit percentage \cite{ref}. %(assumption, need test result or proof), 
% Results with sub-paths shared by many users and longer, rather than short, paths are preferred to increase the utility of the cached shortest-path results.
% 
% By adding a more intuitive cache replacement policy which takes in to consideration both the usage of each cache item, as well as the coverage of previously often seen queries it is likely that the utility of the cache would be much higher. This addition is shown with the addition of the "`add to cache"' box in figure \ref{fig:advancedroutequery}B, added to show a heuristic\footnote{the actual heuristic will of cause only be defined later} will be used instead of a very simple method like LRU.


%\paragraph{\textbf{Number 3, ideas}}
%use optimal substructure\\
%prefer having longer paths in cache\\
%prefer having paths with subpaths shared by many users\\
%look at utility of cache items, not just usage when designing cache replacement policy.\\
%\begin{itemize}
%\item	prefer often used cache items
%\item	prefer items which cover routes/areas often used in previous queries
%\end{itemize}





%\paragraph{crap}
%We assume a setting where all users are equipped
%with a Mobile Device (MD) able to communicate and
%report the users position. All MDs are online and are
%continuesly reporting the users location at predetermined
%intervals. We use the terms user, mobile device, and
%client interchangeable and denote the set of MDs by
%UN. We expect a MD to be cabable of visualizing
%its current location.
%We assume a 2D scenario, where the movements of
%users uU are restricted to a road network G(V, E).
%V is the set of vertices, where each vertice v ∈ V
%represents either a street intersection or an important
%landmark. E is the set of directed edges augmented
%by edge length and type. Edges are represented by
%a begin/end vertice pair and each edge represents the
%smallest unit of a road segment. e ∈ E, each e being
%a tuple specifying id, start-/end-vertices, length, and
%Road Type (RT) (eid , vs , ve , elength , eRT ). RT is a
%hierarchy of the size/type of road i.e. highway, paved,
%or dirt road (Sec. 5.2).
%The simplest form of trajectory is a collection of tu-
%ples (time, longitude, latitude), ordered by the time
%attribute, but as we will work on a road network and
%in the spatio-temporal domain, such a basic notion of
%trajectories is not appropriate. We define T as the set
%of trajectories, where each trajectory consist of an id
%(tid ), and a sequence of tuples containing an edge and



